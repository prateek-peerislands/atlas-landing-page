import fs from "fs/promises";
import { mongoLogId, MongoLogManager } from "mongodb-log-writer";
import redact from "mongodb-redact";
export const LogId = {
    serverStartFailure: mongoLogId(1000001),
    serverInitialized: mongoLogId(1000002),
    serverCloseRequested: mongoLogId(1000003),
    serverClosed: mongoLogId(1000004),
    serverCloseFailure: mongoLogId(1000005),
    serverDuplicateLoggers: mongoLogId(1000006),
    atlasCheckCredentials: mongoLogId(1001001),
    atlasDeleteDatabaseUserFailure: mongoLogId(1001002),
    atlasConnectFailure: mongoLogId(1001003),
    atlasInspectFailure: mongoLogId(1001004),
    atlasConnectAttempt: mongoLogId(1001005),
    atlasConnectSucceeded: mongoLogId(1001006),
    atlasApiRevokeFailure: mongoLogId(1001007),
    atlasIpAccessListAdded: mongoLogId(1001008),
    atlasIpAccessListAddFailure: mongoLogId(1001009),
    telemetryDisabled: mongoLogId(1002001),
    telemetryEmitFailure: mongoLogId(1002002),
    telemetryEmitStart: mongoLogId(1002003),
    telemetryEmitSuccess: mongoLogId(1002004),
    telemetryMetadataError: mongoLogId(1002005),
    telemetryDeviceIdFailure: mongoLogId(1002006),
    telemetryDeviceIdTimeout: mongoLogId(1002007),
    toolExecute: mongoLogId(1003001),
    toolExecuteFailure: mongoLogId(1003002),
    toolDisabled: mongoLogId(1003003),
    mongodbConnectFailure: mongoLogId(1004001),
    mongodbDisconnectFailure: mongoLogId(1004002),
    toolUpdateFailure: mongoLogId(1005001),
    streamableHttpTransportStarted: mongoLogId(1006001),
    streamableHttpTransportSessionCloseFailure: mongoLogId(1006002),
    streamableHttpTransportSessionCloseNotification: mongoLogId(1006003),
    streamableHttpTransportSessionCloseNotificationFailure: mongoLogId(1006004),
    streamableHttpTransportRequestFailure: mongoLogId(1006005),
    streamableHttpTransportCloseFailure: mongoLogId(1006006),
};
export class LoggerBase {
    info(id, context, message) {
        this.log("info", id, context, message);
    }
    error(id, context, message) {
        this.log("error", id, context, message);
    }
    debug(id, context, message) {
        this.log("debug", id, context, message);
    }
    notice(id, context, message) {
        this.log("notice", id, context, message);
    }
    warning(id, context, message) {
        this.log("warning", id, context, message);
    }
    critical(id, context, message) {
        this.log("critical", id, context, message);
    }
    alert(id, context, message) {
        this.log("alert", id, context, message);
    }
    emergency(id, context, message) {
        this.log("emergency", id, context, message);
    }
}
export class ConsoleLogger extends LoggerBase {
    log(level, id, context, message) {
        message = redact(message);
        console.error(`[${level.toUpperCase()}] ${id.__value} - ${context}: ${message} (${process.pid})`);
    }
}
export class DiskLogger extends LoggerBase {
    constructor(logWriter) {
        super();
        this.logWriter = logWriter;
    }
    static async fromPath(logPath) {
        await fs.mkdir(logPath, { recursive: true });
        const manager = new MongoLogManager({
            directory: logPath,
            retentionDays: 30,
            onwarn: console.warn,
            onerror: console.error,
            gzip: false,
            retentionGB: 1,
        });
        await manager.cleanupOldLogFiles();
        const logWriter = await manager.createLogWriter();
        return new DiskLogger(logWriter);
    }
    log(level, id, context, message) {
        message = redact(message);
        const mongoDBLevel = this.mapToMongoDBLogLevel(level);
        this.logWriter[mongoDBLevel]("MONGODB-MCP", id, context, message);
    }
    mapToMongoDBLogLevel(level) {
        switch (level) {
            case "info":
                return "info";
            case "warning":
                return "warn";
            case "error":
                return "error";
            case "notice":
            case "debug":
                return "debug";
            case "critical":
            case "alert":
            case "emergency":
                return "fatal";
            default:
                return "info";
        }
    }
}
export class McpLogger extends LoggerBase {
    constructor(server) {
        super();
        this.server = server;
    }
    log(level, _, context, message) {
        // Only log if the server is connected
        if (!this.server?.isConnected()) {
            return;
        }
        void this.server.server.sendLoggingMessage({
            level,
            data: `[${context}]: ${message}`,
        });
    }
}
class CompositeLogger extends LoggerBase {
    constructor(...loggers) {
        super();
        this.loggers = [];
        this.setLoggers(...loggers);
    }
    setLoggers(...loggers) {
        if (loggers.length === 0) {
            throw new Error("At least one logger must be provided");
        }
        this.loggers = [...loggers];
    }
    log(level, id, context, message) {
        for (const logger of this.loggers) {
            logger.log(level, id, context, message);
        }
    }
}
const logger = new CompositeLogger(new ConsoleLogger());
export default logger;
//# sourceMappingURL=logger.js.map