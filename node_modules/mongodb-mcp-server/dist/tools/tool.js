import logger, { LogId } from "../common/logger.js";
export class ToolBase {
    get annotations() {
        const annotations = {
            title: this.name,
            description: this.description,
        };
        switch (this.operationType) {
            case "read":
            case "metadata":
            case "connect":
                annotations.readOnlyHint = true;
                annotations.destructiveHint = false;
                break;
            case "delete":
                annotations.readOnlyHint = false;
                annotations.destructiveHint = true;
                break;
            case "create":
            case "update":
                annotations.destructiveHint = false;
                annotations.readOnlyHint = false;
                break;
            default:
                break;
        }
        return annotations;
    }
    constructor(session, config, telemetry) {
        this.session = session;
        this.config = config;
        this.telemetry = telemetry;
    }
    register(server) {
        if (!this.verifyAllowed()) {
            return false;
        }
        const callback = async (...args) => {
            const startTime = Date.now();
            try {
                logger.debug(LogId.toolExecute, "tool", `Executing tool ${this.name}`);
                const result = await this.execute(...args);
                await this.emitToolEvent(startTime, result, ...args).catch(() => { });
                return result;
            }
            catch (error) {
                logger.error(LogId.toolExecuteFailure, "tool", `Error executing ${this.name}: ${error}`);
                const toolResult = await this.handleError(error, args[0]);
                await this.emitToolEvent(startTime, toolResult, ...args).catch(() => { });
                return toolResult;
            }
        };
        server.mcpServer.tool(this.name, this.description, this.argsShape, this.annotations, callback);
        // This is very similar to RegisteredTool.update, but without the bugs around the name.
        // In the upstream update method, the name is captured in the closure and not updated when
        // the tool name changes. This means that you only get one name update before things end up
        // in a broken state.
        // See https://github.com/modelcontextprotocol/typescript-sdk/issues/414 for more details.
        this.update = (updates) => {
            const tools = server.mcpServer["_registeredTools"];
            const existingTool = tools[this.name];
            if (!existingTool) {
                logger.warning(LogId.toolUpdateFailure, "tool", `Tool ${this.name} not found in update`);
                return;
            }
            existingTool.annotations = this.annotations;
            if (updates.name && updates.name !== this.name) {
                existingTool.annotations.title = updates.name;
                delete tools[this.name];
                this.name = updates.name;
                tools[this.name] = existingTool;
            }
            if (updates.description) {
                existingTool.annotations.description = updates.description;
                existingTool.description = updates.description;
                this.description = updates.description;
            }
            if (updates.inputSchema) {
                existingTool.inputSchema = updates.inputSchema;
            }
            server.mcpServer.sendToolListChanged();
        };
        return true;
    }
    // Checks if a tool is allowed to run based on the config
    verifyAllowed() {
        let errorClarification;
        // Check read-only mode first
        if (this.config.readOnly && !["read", "metadata"].includes(this.operationType)) {
            errorClarification = `read-only mode is enabled, its operation type, \`${this.operationType}\`,`;
        }
        else if (this.config.disabledTools.includes(this.category)) {
            errorClarification = `its category, \`${this.category}\`,`;
        }
        else if (this.config.disabledTools.includes(this.operationType)) {
            errorClarification = `its operation type, \`${this.operationType}\`,`;
        }
        else if (this.config.disabledTools.includes(this.name)) {
            errorClarification = `it`;
        }
        if (errorClarification) {
            logger.debug(LogId.toolDisabled, "tool", `Prevented registration of ${this.name} because ${errorClarification} is disabled in the config`);
            return false;
        }
        return true;
    }
    // This method is intended to be overridden by subclasses to handle errors
    handleError(error, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    args) {
        return {
            content: [
                {
                    type: "text",
                    text: `Error running ${this.name}: ${error instanceof Error ? error.message : String(error)}`,
                },
            ],
            isError: true,
        };
    }
    /**
     * Creates and emits a tool telemetry event
     * @param startTime - Start time in milliseconds
     * @param result - Whether the command succeeded or failed
     * @param args - The arguments passed to the tool
     */
    async emitToolEvent(startTime, result, ...args) {
        if (!this.telemetry.isTelemetryEnabled()) {
            return;
        }
        const duration = Date.now() - startTime;
        const metadata = this.resolveTelemetryMetadata(...args);
        const event = {
            timestamp: new Date().toISOString(),
            source: "mdbmcp",
            properties: {
                command: this.name,
                category: this.category,
                component: "tool",
                duration_ms: duration,
                result: result.isError ? "failure" : "success",
            },
        };
        if (metadata?.orgId) {
            event.properties.org_id = metadata.orgId;
        }
        if (metadata?.projectId) {
            event.properties.project_id = metadata.projectId;
        }
        await this.telemetry.emitEvents([event]);
    }
}
//# sourceMappingURL=tool.js.map