"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.functionCtorWithoutProps = functionCtorWithoutProps;
exports.assignAll = assignAll;
exports.pickWithExactKeyMatch = pickWithExactKeyMatch;
exports.assertArgsDefinedType = assertArgsDefinedType;
const errors_1 = require("@mongosh/errors");
function functionCtorWithoutProps(ClassCtor) {
    function fnCtor(...args) {
        if (new.target) {
            return Reflect.construct(ClassCtor, args, new.target);
        }
        return new ClassCtor(...args);
    }
    Object.setPrototypeOf(fnCtor, Object.getPrototypeOf(ClassCtor));
    const nameDescriptor = Object.getOwnPropertyDescriptor(ClassCtor, 'name');
    if (nameDescriptor) {
        Object.defineProperty(fnCtor, 'name', nameDescriptor);
    }
    return fnCtor;
}
function assignAll(target, ...sources) {
    const newDescriptorList = [];
    for (const source of sources) {
        newDescriptorList.push(...Object.entries(Object.getOwnPropertyDescriptors(source)));
    }
    const newDescriptorMap = Object.fromEntries(newDescriptorList);
    for (const key of Object.getOwnPropertyNames(newDescriptorMap)) {
        if (Object.getOwnPropertyDescriptor(target, key)?.configurable === false) {
            target[key] = newDescriptorMap[key].value;
            delete newDescriptorMap[key];
        }
    }
    Object.defineProperties(target, newDescriptorMap);
    return target;
}
function pickWithExactKeyMatch(o, keys) {
    return Object.create(Object.getPrototypeOf(o), Object.fromEntries(Object.entries(Object.getOwnPropertyDescriptors(o)).filter(([k]) => keys.includes(k))));
}
function getAssertCaller(caller) {
    return caller ? ` (${caller})` : '';
}
function assertArgsDefinedType(args, expectedTypes, func) {
    args.forEach((arg, i) => {
        const expected = expectedTypes[i];
        if (arg === undefined) {
            if (expected !== true &&
                Array.isArray(expected) &&
                expected.includes(undefined)) {
                return;
            }
            throw new errors_1.MongoshInvalidInputError(`Missing required argument at position ${i}${getAssertCaller(func)}`, errors_1.CommonErrors.InvalidArgument);
        }
        else if (expected === true) {
            return;
        }
        const expectedTypesList = typeof expected === 'string' ? [expected] : expected;
        const isExpectedTypeof = expectedTypesList.includes(typeof arg);
        const isExpectedBson = expectedTypesList.includes(`bson:${arg?._bsontype}`);
        if (!isExpectedTypeof && !isExpectedBson) {
            const expectedMsg = expectedTypesList
                .filter((e) => e !== undefined)
                .map((e) => e?.replace(/^bson:/, ''))
                .join(' or ');
            throw new errors_1.MongoshInvalidInputError(`Argument at position ${i} must be of type ${expectedMsg}, got ${typeof arg} instead${getAssertCaller(func)}`, errors_1.CommonErrors.InvalidArgument);
        }
    });
}
//# sourceMappingURL=helpers.js.map